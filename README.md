# 开发中常用的设计模式

### 介绍
此仓库下为一些开发中常用的设计模式，均采用**Java**实现。当项目工程比较大时，合理地采用设计模式可以使开发更加简单，后期维护也会更加方便。

### 说明

##### 1. 单例模式（single包）

当整个系统只需要拥有**一个全局对象**时，为了更好地协调系统整体的行为，常常使用单例模式。例如在一个应用中，应该只有一个线程池实例，如果同时存在多个线程池，那么会非常消耗资源。因此，没有理由让它构造多个实例。这种**不能自由构造对象**的情况，就是单例模式的使用场景。例如要访问IO、数据库、线程池等资源时，考虑使用单例模式。

单例模式的实现，常常都是将**构造函数私有化**，只允许在该类的内部进行创建实例对象；通过一个静态方法或者枚举返回单例类对象；在多线程情况下要确保单例类的对象**有且只有一个**；确保单例类对象在反序列化时不会重新构建对象。

常见的单例模式的实现方式有：懒汉模式、双检查锁（DCL）、静态内部类、枚举单例。其中，最佳实现方式为**枚举单例**。

##### 2. 静态工厂模式（factory包）

静态工厂模式是众多工厂模式中的一种，在任何需要生成**复杂对象**的地方，都可以使用工厂模式。

静态工厂模式有一个工厂类，其中的生产方法均为静态，每一个产品类都要实现提供的产品接口。每新增一个产品，该产品就要实现产品接口，并且在工厂类里新增该产品的生产方法。

##### 3. 迭代器模式（iterator包）

迭代器模式常见的应用就如Java中的List、Map、数组等。对容器对象的访问必然会设计遍历算法，如果我们把遍历算法封装在容器中，那么对于容器类来说就承担了过多的功能；如果不提供遍历方法而让使用者自己去实现，又会暴露容器内部的实现细节。迭代器模式的产生，很好地解决了这些弊端，**屏蔽了不同容器之间内部实现的差异**，使容器遍历可以通用。

##### 4. 适配器模式（adapter包）

接触过安卓开发的同学应该对适配器不陌生，安卓开放中常用到的ListView、GridView、RecyclerView等控件都会用到**Adapter**，这里的Adapter使用的就是适配器模式；其实在swing的开发中，JTable所用到的**TableModel**也是一种适配器，只不过是换了一个名字而已。

适配器模式是将一个类的接口变成客户端所期待的另一种接口，从而**使原来因接口不匹配而无法一起工作的两个类能够在一起工作**。系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些在将来引进的类一起工作；需要一个统一的输出接口，而输入端的类型不可预知，在上述几种情况下，皆可使用适配器模式。

适配器模式分为类适配器模式和对象适配器模式，代码里只列出了**类适配器模式**，对象适配器模式是将继承改为了聚合的方式。

##### 5. 观察者模式（observer包）

观察者模式定义了对象之间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。它最常用的地方是**GUI系统、订阅——发布系统**，因为这个模式的一个重要作用就是**解耦**，将被观察者和观察者解耦，使得他们之间的依赖性更小。

观察者模式的使用场景有：关联行为场景；事件多级触发场景；跨系统的消息交换场景等。

##### 6. 状态模式（state包）

状态模式是指当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。状态模式的行为是由状态来决定的，**不同状态下有不同的行为**。状态模式和策略模式的结构几乎完全一样，但它们的目的、本质完全不一样。状态模式把对象的行为包装在不同的状态对象里，每一个状态对象都有一个共同的抽象状态基类。

状态模式的使用场景有：一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为；代码中包含大量与对象状态有关的条件语句。